---
title: "DetermineSISO Decision Problem"
description: "Explore the detection of SISO programs"
date: "2025-09-08"
date-format: long
author: Add Your Names Here
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../../../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Theory of computation

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 

- {{< iconify fa6-solid lightbulb >}} **What is theory of computation?**
    - Understanding what can be computed
    - Analyzing computational complexity
    - Proving limits of computation
    - "Proofgrammers" combine *proofs* and *programming*

:::

# What is SISO?
- Single input single out out
- Input (str), splits, converts, computes, stringify, output (str)

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid microscope >}} Keep in mind haulting detector. Haulting detector tells if
a program would stop or run forever.  

:::

## Problem

::: {fragment}
- 1. Undecidability
  - There is no method that can always determine, for any program,
    whether it halts or not (the Halting Problem).

- 2. All-input guarantee
  - Because the input domain is infinite, no finite amount of testing
    can prove that a program halts and outputs exactly once for all inputs.

- 3. Implementation trade-off
  - if we restrict ourselves to a setting where programs always
    terminate—for example, by forbidding loops and general recursion—then
    static analysis can decisively verify that there is exactly one output.
:::

## Conclusion

::: {.fragment}
- In general, it is impossible to realize DetermineSISO as
  a verifier that always returns a correct Yes/No.
- SISO (“halts on all inputs and produces exactly one output”) is
  a non-trivial semantic property; by the Halting Problem, 
  there is no algorithm that can decide it fully automatically
  for arbitrary programs.
:::

