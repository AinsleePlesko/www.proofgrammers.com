---
title: "Impossible Programs"
description: "Exploring fundamental limits of computation"
date: "2025-09-08"
date-format: long
author: Gregory M. Kapfhammer
execute:
  echo: true
format:
  live-revealjs:
    completion: true
    theme: default
    css: ../css/styles.css
    history: false
    scrollable: true
    transition: slide
    highlight-style: github
    footer: "Proofgrammers"
---

# Impossible programs?

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"} 

- {{< iconify fa6-solid lightbulb >}} **The central question of uncomputability**
    - Some problems cannot be solved by any program
    - Even infinite time and memory cannot solve them
    - **This is one of the most profound results in computer science**

:::

::: {.fragment style="margin-top: -0.5em; font-size: 0.8em;"}

- {{< iconify fa6-solid lightbulb >}} **Our exploration strategy**
    - Start with proof by contradiction
    - Build programs that analyze other programs  
    - Demonstrate fundamental impossibility results
    - Connect to practical software engineering limits

:::

## Proof by contradiction

::: {.incremental style="margin-top: -0.15em; font-size: 0.8em;"}

- {{< iconify fa6-solid gear >}} **Natural human reasoning pattern**
  - **Statement S**: "I bought the milk on Monday"
  - **Consequence C**: "I was in town on Monday"  
  - **Known fact T**: "I was out of town on Monday"
  - **Conclusion**: Since C contradicts T, statement S must be false

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.8em;"}

- {{< iconify fa6-solid gear >}} **Mathematical formulation**
  - If $S$ implies $C$, but $C$ is false, then $S$ is false
  - To prove something is true, assume its opposite and seek contradiction
  - Essential technique for impossibility proofs in computer science
  - Note this proof technique does not constructively show what is true

:::

## Programs analyzing other programs

```{pyodide}
#| autorun: true
#| max-lines: 10
def countLines(inString: str) -> str:
    """Count the number of lines in the provided text content."""
    lines = inString.split('\n')
    return str(len(lines))

# simulate reading a program file
def rf(filename: str) -> str:
    """Simulate reading file content for demonstration."""
    sample_programs = {
        "multiply.py": '''def multiply(x, y):
    return str(int(x) * int(y))

result = multiply("6", "7")
print(f"Result: {result}")''',
        "countLines.py": '''def countLines(inString):
    lines = inString.split('\\n')
    return str(len(lines))'''
    }
    return sample_programs.get(filename, "# File not found")

# demonstrate program analyzing another program
multiply_program = rf("multiply.py")
line_count = countLines(multiply_program)
print(f"The multiply.py program has {line_count} lines")

# demonstrate program analyzing itself
countlines_program = rf("countLines.py")
self_count = countLines(countlines_program)
print(f"The countLines.py program has {self_count} lines")
```

::: {.fragment style="margin-top: 0.25em; font-size: 0.9em;"}

- A program can analyze itself or another program
- Completed at the level of source code text or output

:::

## Self-reflection in computation

::: {.incremental style="margin-top: 0.25em; font-size: 0.9em;"}

- {{< iconify fa6-solid diagram-project >}} **Programs can analyze themselves**:
    - `countLines(rf('countLines.py'))` reports its line count
    - Similar to how human brains can think about thinking
    - **Key**: programs can examine their own structure

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.9em;"}

- {{< iconify fa6-solid diagram-project >}} **Self-reflection extends and limits computation**:
    - Self-reflection enables powerful computation
    - But it also creates fundamental limitations
    - Capability that makes programs powerful also constrains them
    - **Key**: Some problems become impossible due to self-reflection

:::

# Foundation of impossibility

::: incremental

- Programs can analyze themselves
- Programs can analyze other programs
- Self-reflection creates contradictions
- Proof by contradiction reveals impossibility
- Discover fundamental limits of computation

:::

## Decision programs we need

```{pyodide}
#| autorun: true  
#| max-lines: 10
def containsGAGA(inString: str) -> str:
    """Return yes if input contains GAGA."""
    if 'GAGA' in inString:
        return 'yes'
    else:
        return 'no'

def yes(inString: str) -> str:
    """Always return yes, ignoring input."""
    return 'yes'

def longerThan1K(inString: str) -> str:
    """Return yes if input is longer than 1000 characters."""
    if len(inString) > 1000:
        return 'yes'
    else:
        return 'no'

def maybeLoop(inString: str) -> str:
    """Return yes/no for inputs with 'secret sauce', loop otherwise."""
    if 'secret sauce' not in inString:
        # infinite loop simulation - don't actually loop
        return 'undefined (infinite loop)'
    else:
        if len(inString) % 2 == 0:
            return 'yes'
        else:
            return 'no'

# test the decision programs
test_cases = ['CTGAGAT', 'programming', 'some secret sauce here']
for test in test_cases:
    print(f"Input: '{test}'")
    print(f"  containsGAGA: {containsGAGA(test)}")
    print(f"  yes: {yes(test)}")
    print(f"  longerThan1K: {longerThan1K(test)}")
    print(f"  maybeLoop: {maybeLoop(test)}")
    print()
```

## Program analysis examples

```{python}
# Define analysis functions
def containsGAGA(inString: str) -> str:
    return 'yes' if 'GAGA' in inString else 'no'

def yes(inString: str) -> str:
    return 'yes'

def longerThan1K(inString: str) -> str:
    return 'yes' if len(inString) > 1000 else 'no'

# Simulate program files
programs = {
    'containsGAGA.py': 'def containsGAGA(inString):\n    return "yes" if "GAGA" in inString else "no"',
    'yes.py': 'def yes(inString):\n    return "yes"',
    'geneticString.txt': 'CTGAGAATTCGAGA'
}

def rf(filename: str) -> str:
    return programs.get(filename, 'File not found')

# Programs analyzing other programs
examples = [
    ("containsGAGA('CTGAGAT')", containsGAGA('CTGAGAT')),
    ("containsGAGA(rf('geneticString.txt'))", containsGAGA(rf('geneticString.txt'))),
    ("yes(rf('containsGAGA.py'))", yes(rf('containsGAGA.py')))
]

for command, result in examples:
    print(f"{command} = {result}")
```

## The hypothetical yesOnString program

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- **Definition**: `yesOnString(P, I)` returns:
  - `"yes"` if P is a valid Python program, P(I) is defined, and P(I) = "yes"
  - `"no"` otherwise (invalid program, undefined output, or non-"yes" result)

:::

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- **Question it answers**: Does program P return "yes" on input string I?
- **Important note**: We don't provide the source code for `yesOnString`
- **Reason**: We will prove it's impossible to write such a program!

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid microscope >}} The `yesOnString` program would solve a fundamental question about program behavior. But as we'll see, asking this question leads to logical contradictions that make the program impossible.

:::

## Examples with hypothetical yesOnString

```{python}
# Hypothetical behavior (we'll prove this can't exist!)
def hypothetical_yesOnString(P: str, I: str) -> str:
    """HYPOTHETICAL: Check if program P returns 'yes' on input I."""
    if P == "containsGAGA.py" and I == "CTGAGAT":
        return "yes"  
    elif P == "containsGAGA.py" and I == "hello":
        return "no"   
    elif P == "yes.py":
        return "yes"  
    else:
        return "no"   
        
# Show theoretical behavior
examples = [
    ("containsGAGA.py", "CTGAGAT"),
    ("containsGAGA.py", "hello"),  
    ("yes.py", "anything")
]

print("Hypothetical yesOnString behavior:")
for prog, input_str in examples:
    result = hypothetical_yesOnString(prog, input_str)
    print(f"yesOnString('{prog}', '{input_str}') = {result}")

print("\nBut we will prove this program cannot exist!")
```

## The yesOnSelf simplification

::: {.incremental style="margin-top: 0.1em; font-size: 0.9em;"}

- **Definition**: `yesOnSelf(P)` returns:
  - `"yes"` if P is a valid Python program and P(P) = "yes"
  - `"no"` otherwise

:::

::: {.incremental style="margin-top: 0.1em; font-size: 0.9em;"}

- **Relationship to yesOnString**: 
  - `yesOnSelf(P)` = `yesOnString(P, P)`
  - Asks: "Does program P return 'yes' when given itself as input?"
  
:::

::: {.incremental style="margin-top: 0.1em; font-size: 0.9em;"}

- **Why this matters**: 
  - Simpler to analyze than the two-parameter version
  - Self-application creates the conditions for contradiction
  - **Foundation of the impossibility proof**

:::

## Examples with hypothetical yesOnSelf  

```{python}
# Hypothetical behavior of yesOnSelf
def hypothetical_yesOnSelf(P: str) -> str:
    """HYPOTHETICAL: Check if program P returns 'yes' on itself."""
    if P == "yes.py":
        return "yes"  # yes("yes.py") = "yes"
    elif P == "containsGAGA.py":
        return "yes"  # containsGAGA.py contains "GAGA"
    else:
        return "no"   # default case

# Show examples
test_programs = ["yes.py", "containsGAGA.py", "longerThan1K.py"]

print("Hypothetical yesOnSelf behavior:")
for prog in test_programs:
    result = hypothetical_yesOnSelf(prog)
    print(f"yesOnSelf('{prog}') = {result}")

print("\nRemember: We're assuming yesOnSelf exists to derive a contradiction!")
```

## The devastating notYesOnSelf program

```{python}
# Here's where the contradiction emerges!
def notYesOnSelf(P: str) -> str:
    """Return the opposite of what yesOnSelf would return."""
    result = hypothetical_yesOnSelf(P)
    return "no" if result == "yes" else "yes"

# Test on some programs
test_cases = ["yes.py", "containsGAGA.py"]
for prog in test_cases:
    yes_result = hypothetical_yesOnSelf(prog)
    not_result = notYesOnSelf(prog) 
    print(f"yesOnSelf('{prog}') = {yes_result}")
    print(f"notYesOnSelf('{prog}') = {not_result}")
    print()

# The critical question
print("THE CRITICAL CASE:")
print("What is notYesOnSelf('notYesOnSelf.py')?")
print("This creates the contradiction!")
```

## The contradiction revealed

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

**Consider**: `notYesOnSelf("notYesOnSelf.py")`

- **If it returns "yes"**: Then `yesOnSelf("notYesOnSelf.py")` = "no"
- **But if yesOnSelf returns "no"**: Then notYesOnSelf should return "yes"  
- **So**: notYesOnSelf returns "yes" when run on itself

:::

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

**But also**:

- **If it returns "no"**: Then `yesOnSelf("notYesOnSelf.py")` = "yes"  
- **But if yesOnSelf returns "yes"**: Then notYesOnSelf should return "no"
- **So**: notYesOnSelf returns "no" when run on itself

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid exclamation-triangle >}} **Contradiction**: notYesOnSelf returns "yes" if and only if it returns "no"! No program can have this property, so notYesOnSelf cannot exist.

:::

# The complete impossibility proof

## The impossibility proof structure

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **Step 1: Proof by contradiction**
  - Assume `yesOnString` exists (our statement S)
  - This would allow us to create `yesOnSelf` 
  - And then create `notYesOnSelf`

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **Step 2: Derive contradiction**
  - `notYesOnSelf("notYesOnSelf.py")` creates logical contradiction
  - Returns "yes" if and only if it returns "no"
  - No program can have this impossible property

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **Step 3: Conclude impossibility**
  - Since assuming `yesOnString` exists leads to contradiction
  - `yesOnString` cannot exist
  - **This is our first major impossibility result!**

:::

## Compact impossibility proof

```{python}
# Direct proof using the "weird" program technique
def weirdYesOnString(P: str) -> str:
    """The program that creates immediate contradiction."""
    result = hypothetical_yesOnString(P, P)  # yesOnString(P, P)
    return "no" if result == "yes" else "yes"

print("Direct contradiction approach:")
print("What is weirdYesOnString('weirdYesOnString.py')?")
print("")
print("If result = 'yes':")
print("  Then yesOnString says weirdYesOnString returns 'yes'")
print("  But weirdYesOnString should return 'no' - contradiction!")
print("")
print("If result = 'no':")
print("  Then yesOnString says weirdYesOnString doesn't return 'yes'") 
print("  But weirdYesOnString should return 'yes' - contradiction!")
print("")
print("CONCLUSION: yesOnString cannot exist.")
```

## Crash detection is also impossible

```{python}
def weirdCrashOnSelf(P: str) -> str:
    """Reveals crash detection impossibility."""
    # Assumes crashOnString exists (it doesn't!)
    def hypothetical_crashOnString(prog: str, input_str: str) -> str:
        return "no"  # Placeholder - this is impossible!
    
    crash_result = hypothetical_crashOnString(P, P)
    
    if crash_result == "yes":
        return "no crash here"  # Don't crash if P crashes on itself
    else:
        return "simulated crash"  # Crash if P doesn't crash on itself

print("Crash detection impossibility:")
print("Consider: weirdCrashOnSelf('weirdCrashOnSelf.py')")
print("")
print("Case 1: If weirdCrashOnSelf crashes on itself")
print("  → crashOnString says 'yes', so weirdCrashOnSelf doesn't crash")
print("  → Contradiction!")
print("")
print("Case 2: If weirdCrashOnSelf doesn't crash")
print("  → crashOnString says 'no', so weirdCrashOnSelf crashes") 
print("  → Contradiction!")
print("")
print("Conclusion: crashOnString cannot exist!")
```

## Practical implications 

::: {.incremental style="margin-top: -0.15em; font-size: 0.9em;"}

- {{< iconify fa6-solid gear >}} **No perfect bug finder**
  - Cannot create a program that finds all bugs in all programs
  - Static analysis tools work on many cases but not universally
  - Software companies invest heavily in partial solutions

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.9em;"}

- {{< iconify fa6-solid gear >}} **No universal crash detector**
  - Cannot predict crashes for all possible program inputs
  - Testing and runtime monitoring remain essential
  - Impossibility doesn't mean "useless" - means "not universal"

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.9em;"}

- {{< iconify fa6-solid gear >}} **Fundamental computational limits**
  - Some problems are unsolvable even with infinite resources
  - **Proofgrammers must understand these boundaries**

:::

## Try self-analysis experiments

```{pyodide}
#| autorun: true
#| max-lines: 6
def analyzeProgram(program_code: str) -> str:
    """Analyze properties of a program given as a string."""
    lines = len(program_code.split('\n'))
    words = len(program_code.split())
    has_loop = 'while' in program_code or 'for' in program_code
    return f"Lines: {lines}; Words: {words}; Has loops: {has_loop}"

# Test the analyzer on itself!
analyzer_code = '''def analyzeProgram(code):
    lines = len(code.split('\\n'))
    return f"Lines: {lines}"'''

self_analysis = analyzeProgram(analyzer_code)
print("Program analyzing itself:")
print(f"Analysis: {self_analysis}")
print("\nNote: This self-analysis is possible!")
print("But universal crash detection is impossible.")
```

## Theoretical limits vs practical tools

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **What IS impossible**
  - Universal bug detection for all programs
  - Perfect crash prediction for all inputs  
  - Determining if any arbitrary program halts

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **What IS possible**
  - Bug detection for many specific program classes
  - Crash prediction for many common scenarios
  - Static analysis tools that work on practical codebases

:::

::: {.incremental style="margin-top: -0.15em; font-size: 0.85em;"}

- {{< iconify fa6-solid gear >}} **Proofgrammer perspective**  
  - Impossibility results guide what tools to build
  - Focus effort on solvable subproblems
  - Understand fundamental computational boundaries

:::

# Foundational results

## Why impossibility matters

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- {{< iconify game-icons team-idea >}} **Scientific understanding:**
  - Reveals fundamental limits of computation itself
  - Not about hardware limitations or current technology
  - Shows logical boundaries that no algorithm can cross

:::

::: {.fragment style="margin-top: 0.1em; font-size: 0.85em;"}

- {{< iconify game-icons team-idea >}} **Practical guidance:**
  - Helps avoid impossible engineering goals
  - Guides research toward productive directions  
  - Explains why some software problems are persistently difficult
  - **Informs realistic expectations for automated tools**

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid microscope >}} Understanding impossibility is as important as understanding possibility. It prevents wasted effort on unsolvable problems and focuses innovation on achievable goals.

:::

## Key takeaways

::: {.incremental style="margin-top: -0.15em; font-size: 0.9em;"}

- {{< iconify fa6-solid gear >}} **Proof by contradiction**: Natural technique for impossibility results  
- {{< iconify fa6-solid microscope >}} **Self-reflection paradox**: Programs analyzing themselves creates contradictions
- {{< iconify fa6-solid diagram-project >}} **Universal impossibilities**: `yesOnString` and `crashOnString` cannot exist
- {{< iconify fa6-solid book-open >}} **Practical implications**: Static analysis works on subproblems, not universally  

:::

## More key insights

::: {.incremental style="margin-top: -0.15em; font-size: 0.9em;"}

- {{< iconify fa6-solid gears >}} **Theoretical foundation**: Uncomputability theory guides CS boundaries
- {{< iconify fa6-solid lightbulb >}} **Proofgrammer insight**: Some problems are fundamentally unsolvable
- {{< iconify fa6-solid rocket >}} **Next exploration**: Turing machines and formal computation models
- {{< iconify fa6-solid compass >}} **Deep understanding**: Computational limits matter as much as capabilities

:::

## Looking ahead

::: {.incremental style="margin-top: -0.15em; font-size: 0.9em;"}

- **Chapter 4**: Turing machines as formal computational models  
- **Chapter 5**: Universal computation and Church-Turing thesis
- **Chapters 6-7**: More impossibility results and undecidability
- **Chapters 8+**: Complexity theory and tractable vs intractable problems

:::

::: {.fragment .fade .boxed-content style="margin-top: 0.25em; font-size: 0.9em;"}

{{< iconify fa6-solid lightbulb >}} The impossibility results we've discovered are just the beginning. The landscape of uncomputability reveals profound truths about the nature of computation itself. **Welcome to the deep end of theoretical computer science!**

:::
